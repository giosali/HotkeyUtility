{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HotkeyUtility A simple library for setting and managing global hotkeys for WPF Requirements HotkeyUtility is compatible with .NET 5.0 ( net5.0-windows ) and .NET 6.0 ( net6.0-windows ). Installation You can find the package on NuGet or install it through PackageManagement: Install-Package HotkeyUtility","title":"Home"},{"location":"#requirements","text":"HotkeyUtility is compatible with .NET 5.0 ( net5.0-windows ) and .NET 6.0 ( net6.0-windows ).","title":"Requirements"},{"location":"#installation","text":"You can find the package on NuGet or install it through PackageManagement: Install-Package HotkeyUtility","title":"Installation"},{"location":"advanced_usage/","text":"Advanced Usage This page goes more in depth on some of the features and inner workings of the HotkeyUtility package. Binding One of the more convenient features of HotkeyUtility is that its objects and controls support binding to its properties. The Combination Property Both HotkeyBinding and VisualHotkey contain a dependency property called Combination , which is a KeyBinding . This means that if you bind a KeyBinding to the Combination property, the hotkey(s) in your application can be changed at runtime. Info The Combination property is really just a KeyBinding in disguise. This provides a significant advantage over the Gesture property of a KeyBinding because the Gesture property doesn't allow certain combinations like Shift + M or Shift + 1 . Using HotkeyUtility Programmatically So far, you've really only seen HotkeyUtility used in XAML but what if you're more of a codebehind kind of person? Well, don't worry because you can simply use the HotkeyManager class to add, remove, or replace hotkeys. The HotkeyManager class exposes the following methods that you can use: GetHotkeyManager TryAddHotkey TryRemoveHotkey TryReplaceHotkey GetHotkeys Getting Started In order to get an instance of the HotkeyManager class, you need to use its GetHotkeyManager method. The HotkeyManager class uses the singleton design pattern which means that as long as you access your HotkeyManager from the same thread that created it in the first place, you'll always have access to your hotkeys. Here's a simple example of how we can go about creating an instance of HotkeyManager for the first time in our application: ShellViewModel.cs 1 2 3 4 5 6 using HotkeyUtility ; public void InstantiateHotkeyManager () { HotkeyManager hotkeyManager = HotkeyManager . GetHotkeyManager (); } Now, let's say that we've added some hotkeys to our HotkeyManager (which we'll get to soon in another section) and we want to interact with them in another file. Well, we can do exactly that by calling the same method: OtherViewModel.cs 1 2 3 4 5 6 7 using HotkeyUtility ; public void InstantiateHotkeyManager () { // This is the same instance as the one in the previous file HotkeyManager hotkeyManager = HotkeyManager . GetHotkeyManager (); } Adding Hotkeys If you want to programmatically add a hotkey to your application, you'll need to: Create a Hotkey object Use the TryAddHotkey method on HotkeyManager to add it The Hotkey class has the following signature for its constructor: 1 public Hotkey ( Key key , ModifierKeys modifiers , EventHandler < HotkeyEventArgs > handler , ushort id = default ) You'll need to pass it a Key , a ModifierKeys , and an event handler that will be subscribed to the Pressed event that will trigger when the hotkey is pressed. Once you've created your Hotkey , pass it to the TryAddHotkey method of an instance of the HotkeyManager class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 using System ; using System.Windows.Input ; using HotkeyUtility ; public static void Main () { Key key = Key . A ; ModifierKeys modifiers = ModifierKeys . Shift | ModifierKeys . Control ; Hotkey hotkey = new ( key , modifiers , Hotkey_Pressed ); HotkeyManager hotkeyManager = HotkeyManager . GetHotkeyManager (); _ = hotkeyManager . TryAddHotkey ( hotkey ); } public static void Hotkey_Pressed ( object sender , HotkeyEventArgs e ) { Console . WriteLine (); } The TryAddHotkey method returns a bool indicating whether or not the operation was successful. Removing Hotkeys If you want to remove a hotkey from your application, you can do so by passing the same Hotkey object to the TryRemoveHotkey method of HotkeyManager : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 using System ; using System.Windows.Input ; using HotkeyUtility ; public static void Main () { Key key = Key . A ; ModifierKeys modifiers = ModifierKeys . Shift | ModifierKeys . Control ; Hotkey hotkey = new ( key , modifiers , Hotkey_Pressed ); HotkeyManager hotkeyManager = HotkeyManager . GetHotkeyManager (); _ = hotkeyManager . TryAddHotkey ( hotkey ); _ = hotkeyManager . TryRemoveHotkey ( hotkey ); } public static void Hotkey_Pressed ( object sender , HotkeyEventArgs e ) { Console . WriteLine (); } Now, Ctrl + Shift + A will be unregistered from your application. The TryRemoveHotkey method returns a bool indicating whether or not the operation was successful. Replacing Hotkeys The TryReplaceHotkey method works by unregistering an existing Hotkey and reregistering it with a new Key , a new ModifierKeys , or both and returns a boolean indicating whether the operation was successful. This method consists of two overloaded methods. Here are both of their signatures: First signature 1 public bool TryReplaceHotkey ( Key oldKey , ModifierKeys oldModifiers , Key newKey = Key . None , ModifierKeys newModifiers = ModifierKeys . None ) Second signature 1 public bool TryReplaceHotkey ( ushort id , Key newKey = Key . None , ModifierKeys newModifiers = ModifierKeys . None ) First Overloaded Method For the first signature, all you need are the Key and ModifierKeys of an existing Hotkey object for the first two parameters. These will be used to iterate through the current hotkeys until it finds a matching Key and ModifierKeys. The newKey and newModifiers parameters will then be used to replace the binding of the existing Hotkey . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 using System ; using System.Windows.Input ; using HotkeyUtility ; public static void Main () { HotkeyManager hotkeyManager = HotkeyManager . GetHotkeyManager (); Hotkey hotkey = new ( Key . A , ModifierKeys . Shift | ModifierKeys . Control , Hotkey_Pressed ); _ = hotkeyManager . TryAddHotkey ( hotkey ); // Now, pressing Shift + Control + A is no longer registered and Hotkey_Pressed // will no longer be triggered by that hotkey. // Instead, Hotkey_Pressed will now be triggered by pressing Alt + B. _ = hotkeyManager . TryReplaceHotkey ( Key . A , ModifierKeys . Shift | ModifierKeys . Control , Key . B , ModifierKeys . Alt ); } public static void Hotkey_Pressed ( object sender , HotkeyEventArgs e ) { Console . WriteLine (); } Second Overloaded Method As for the second signature, the first parameter must be filled by the Id of an existing Hotkey . If the Id is a match, the newKey and newModifiers parameters will be used to replace the binding of the existing Hotkey . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 using System ; using System.Windows.Input ; using HotkeyUtility ; public static void Main () { HotkeyManager hotkeyManager = HotkeyManager . GetHotkeyManager (); Hotkey hotkey = new ( Key . A , ModifierKeys . Shift | ModifierKeys . Control , Hotkey_Pressed ); _ = hotkeyManager . TryAddHotkey ( hotkey ); // Now, pressing Shift + Control + A is no longer registered and Hotkey_Pressed // will no longer be triggered by that hotkey. // Instead, Hotkey_Pressed will now be triggered by pressing Alt + B. hotkeyManager . TryReplaceHotkey ( hotkey . Id , Key . B , ModifierKeys . Alt ); } public static void Hotkey_Pressed ( object sender , HotkeyEventArgs e ) { Console . WriteLine (); } Viewing Your Hotkeys You can iterate over all of your current hotkeys by calling the GetHotkeys method. This will return a ValueCollection of Hotkey objects that you can then iterate over: 1 2 3 4 5 6 7 8 9 10 11 using System ; using HotkeyUtility ; public static void Main () { HotkeyManager hotkeyManager = HotkeyManager . GetHotkeyManager (); foreach ( Hotkey hotkey in hotkeyManager . GetHotkeys ()) { // Do something here } } Additionally, HotkeyUtility provides an extension method called Find that you can use alongside the GetHotkeys method to quickly and compactly find a single Hotkey in the ValueCollection . Pass the method a Key and ModifierKeys to find and match the existing Hotkey . If a match was found, the expected Hotkey will be returned; otherwise, null will be returned. 1 2 3 4 5 6 7 8 9 using System ; using HotkeyUtility ; using HotkeyUtility.Extensions ; public static void Main () { HotkeyManager hotkeyManager = HotkeyManager . GetHotkeyManager (); Hotkey hotkey = hotkeyManager . GetHotkeys (). Find ( Key . Space , ModifierKeys . Control ); }","title":"Advanced Usage"},{"location":"advanced_usage/#advanced-usage","text":"This page goes more in depth on some of the features and inner workings of the HotkeyUtility package.","title":"Advanced Usage"},{"location":"advanced_usage/#binding","text":"One of the more convenient features of HotkeyUtility is that its objects and controls support binding to its properties.","title":"Binding"},{"location":"advanced_usage/#the-combination-property","text":"Both HotkeyBinding and VisualHotkey contain a dependency property called Combination , which is a KeyBinding . This means that if you bind a KeyBinding to the Combination property, the hotkey(s) in your application can be changed at runtime. Info The Combination property is really just a KeyBinding in disguise. This provides a significant advantage over the Gesture property of a KeyBinding because the Gesture property doesn't allow certain combinations like Shift + M or Shift + 1 .","title":"The Combination Property"},{"location":"advanced_usage/#using-hotkeyutility-programmatically","text":"So far, you've really only seen HotkeyUtility used in XAML but what if you're more of a codebehind kind of person? Well, don't worry because you can simply use the HotkeyManager class to add, remove, or replace hotkeys. The HotkeyManager class exposes the following methods that you can use: GetHotkeyManager TryAddHotkey TryRemoveHotkey TryReplaceHotkey GetHotkeys","title":"Using HotkeyUtility Programmatically"},{"location":"advanced_usage/#getting-started","text":"In order to get an instance of the HotkeyManager class, you need to use its GetHotkeyManager method. The HotkeyManager class uses the singleton design pattern which means that as long as you access your HotkeyManager from the same thread that created it in the first place, you'll always have access to your hotkeys. Here's a simple example of how we can go about creating an instance of HotkeyManager for the first time in our application: ShellViewModel.cs 1 2 3 4 5 6 using HotkeyUtility ; public void InstantiateHotkeyManager () { HotkeyManager hotkeyManager = HotkeyManager . GetHotkeyManager (); } Now, let's say that we've added some hotkeys to our HotkeyManager (which we'll get to soon in another section) and we want to interact with them in another file. Well, we can do exactly that by calling the same method: OtherViewModel.cs 1 2 3 4 5 6 7 using HotkeyUtility ; public void InstantiateHotkeyManager () { // This is the same instance as the one in the previous file HotkeyManager hotkeyManager = HotkeyManager . GetHotkeyManager (); }","title":"Getting Started"},{"location":"advanced_usage/#adding-hotkeys","text":"If you want to programmatically add a hotkey to your application, you'll need to: Create a Hotkey object Use the TryAddHotkey method on HotkeyManager to add it The Hotkey class has the following signature for its constructor: 1 public Hotkey ( Key key , ModifierKeys modifiers , EventHandler < HotkeyEventArgs > handler , ushort id = default ) You'll need to pass it a Key , a ModifierKeys , and an event handler that will be subscribed to the Pressed event that will trigger when the hotkey is pressed. Once you've created your Hotkey , pass it to the TryAddHotkey method of an instance of the HotkeyManager class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 using System ; using System.Windows.Input ; using HotkeyUtility ; public static void Main () { Key key = Key . A ; ModifierKeys modifiers = ModifierKeys . Shift | ModifierKeys . Control ; Hotkey hotkey = new ( key , modifiers , Hotkey_Pressed ); HotkeyManager hotkeyManager = HotkeyManager . GetHotkeyManager (); _ = hotkeyManager . TryAddHotkey ( hotkey ); } public static void Hotkey_Pressed ( object sender , HotkeyEventArgs e ) { Console . WriteLine (); } The TryAddHotkey method returns a bool indicating whether or not the operation was successful.","title":"Adding Hotkeys"},{"location":"advanced_usage/#removing-hotkeys","text":"If you want to remove a hotkey from your application, you can do so by passing the same Hotkey object to the TryRemoveHotkey method of HotkeyManager : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 using System ; using System.Windows.Input ; using HotkeyUtility ; public static void Main () { Key key = Key . A ; ModifierKeys modifiers = ModifierKeys . Shift | ModifierKeys . Control ; Hotkey hotkey = new ( key , modifiers , Hotkey_Pressed ); HotkeyManager hotkeyManager = HotkeyManager . GetHotkeyManager (); _ = hotkeyManager . TryAddHotkey ( hotkey ); _ = hotkeyManager . TryRemoveHotkey ( hotkey ); } public static void Hotkey_Pressed ( object sender , HotkeyEventArgs e ) { Console . WriteLine (); } Now, Ctrl + Shift + A will be unregistered from your application. The TryRemoveHotkey method returns a bool indicating whether or not the operation was successful.","title":"Removing Hotkeys"},{"location":"advanced_usage/#replacing-hotkeys","text":"The TryReplaceHotkey method works by unregistering an existing Hotkey and reregistering it with a new Key , a new ModifierKeys , or both and returns a boolean indicating whether the operation was successful. This method consists of two overloaded methods. Here are both of their signatures: First signature 1 public bool TryReplaceHotkey ( Key oldKey , ModifierKeys oldModifiers , Key newKey = Key . None , ModifierKeys newModifiers = ModifierKeys . None ) Second signature 1 public bool TryReplaceHotkey ( ushort id , Key newKey = Key . None , ModifierKeys newModifiers = ModifierKeys . None )","title":"Replacing Hotkeys"},{"location":"advanced_usage/#first-overloaded-method","text":"For the first signature, all you need are the Key and ModifierKeys of an existing Hotkey object for the first two parameters. These will be used to iterate through the current hotkeys until it finds a matching Key and ModifierKeys. The newKey and newModifiers parameters will then be used to replace the binding of the existing Hotkey . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 using System ; using System.Windows.Input ; using HotkeyUtility ; public static void Main () { HotkeyManager hotkeyManager = HotkeyManager . GetHotkeyManager (); Hotkey hotkey = new ( Key . A , ModifierKeys . Shift | ModifierKeys . Control , Hotkey_Pressed ); _ = hotkeyManager . TryAddHotkey ( hotkey ); // Now, pressing Shift + Control + A is no longer registered and Hotkey_Pressed // will no longer be triggered by that hotkey. // Instead, Hotkey_Pressed will now be triggered by pressing Alt + B. _ = hotkeyManager . TryReplaceHotkey ( Key . A , ModifierKeys . Shift | ModifierKeys . Control , Key . B , ModifierKeys . Alt ); } public static void Hotkey_Pressed ( object sender , HotkeyEventArgs e ) { Console . WriteLine (); }","title":"First Overloaded Method"},{"location":"advanced_usage/#second-overloaded-method","text":"As for the second signature, the first parameter must be filled by the Id of an existing Hotkey . If the Id is a match, the newKey and newModifiers parameters will be used to replace the binding of the existing Hotkey . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 using System ; using System.Windows.Input ; using HotkeyUtility ; public static void Main () { HotkeyManager hotkeyManager = HotkeyManager . GetHotkeyManager (); Hotkey hotkey = new ( Key . A , ModifierKeys . Shift | ModifierKeys . Control , Hotkey_Pressed ); _ = hotkeyManager . TryAddHotkey ( hotkey ); // Now, pressing Shift + Control + A is no longer registered and Hotkey_Pressed // will no longer be triggered by that hotkey. // Instead, Hotkey_Pressed will now be triggered by pressing Alt + B. hotkeyManager . TryReplaceHotkey ( hotkey . Id , Key . B , ModifierKeys . Alt ); } public static void Hotkey_Pressed ( object sender , HotkeyEventArgs e ) { Console . WriteLine (); }","title":"Second Overloaded Method"},{"location":"advanced_usage/#viewing-your-hotkeys","text":"You can iterate over all of your current hotkeys by calling the GetHotkeys method. This will return a ValueCollection of Hotkey objects that you can then iterate over: 1 2 3 4 5 6 7 8 9 10 11 using System ; using HotkeyUtility ; public static void Main () { HotkeyManager hotkeyManager = HotkeyManager . GetHotkeyManager (); foreach ( Hotkey hotkey in hotkeyManager . GetHotkeys ()) { // Do something here } } Additionally, HotkeyUtility provides an extension method called Find that you can use alongside the GetHotkeys method to quickly and compactly find a single Hotkey in the ValueCollection . Pass the method a Key and ModifierKeys to find and match the existing Hotkey . If a match was found, the expected Hotkey will be returned; otherwise, null will be returned. 1 2 3 4 5 6 7 8 9 using System ; using HotkeyUtility ; using HotkeyUtility.Extensions ; public static void Main () { HotkeyManager hotkeyManager = HotkeyManager . GetHotkeyManager (); Hotkey hotkey = hotkeyManager . GetHotkeys (). Find ( Key . Space , ModifierKeys . Control ); }","title":"Viewing Your Hotkeys"},{"location":"quickstart/","text":"Quickstart HotkeyUtility is designed and intended to be intuitive and easy to use. This page will show a couple of quick examples to get you started using hotkeys in your WPF applications. Creating a Hotkey Setting up a hotkey in your application is easy. We first need to declare the HotkeyUtility XAML namespace in the root tag of your XAML file: MainWindow.xaml 1 2 3 4 5 6 7 <Window xmlns= \"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x= \"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:d= \"http://schemas.microsoft.com/expression/blend/2008\" xmlns:mc= \"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns:hu= \"clr-namespace:HotkeyUtility.Controls;assembly=HotkeyUtility\" > </Window> Once the namespace is declared, you can use the HotkeyBinding object (which inherits from InputBinding ) that's provided to you by HotkeyUtility : Simply add it to the InputBindings property of the Window : MainWindow.xaml 1 2 3 4 5 6 7 8 9 10 <Window xmlns= \"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x= \"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:d= \"http://schemas.microsoft.com/expression/blend/2008\" xmlns:mc= \"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns:hu= \"clr-namespace:HotkeyUtility.Controls;assembly=HotkeyUtility\" > <Window.InputBindings> <hu:HotkeyBinding Combination= \"Alt + Space\" Pressed= \"HotkeyBinding_Pressed\" /> </Window.InputBindings> </Window> Once that's set up, your hotkey is now registered and ready to be used. Whenever the user simultaneously presses Alt + Space , the event handler called HotkeyBinding_Pressed in the codebehind will be triggered: MainWindow.xaml.cs 1 2 3 4 5 6 7 using System ; using HotkeyUtility.Input ; public void HotkeyBinding_Pressed ( object sender , HotkeyEventArgs e ) { Console . WriteLine ( \"A hotkey was pressed\" ); } Hotkeys and MVVM If you're using an MVVM framework (like Caliburn.Micro , for example), there's a chance that attaching an event handler to the Pressed event of HotkeyBinding won't work. If that's the case for you, you'll need to use the VisualHotkey control provided by HotkeyUtility . It's important to point out that the name is a bit of a misnomer; VisualHotkey has no visual properties so it won't take up any space in your application. You can use it in your XML file like in this example (which uses Caliburn.Micro ): ShellView.xaml 1 2 3 4 5 6 7 8 9 10 11 <Window xmlns= \"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x= \"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:d= \"http://schemas.microsoft.com/expression/blend/2008\" xmlns:mc= \"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns:hu= \"clr-namespace:HotkeyUtility.Controls;assembly=HotkeyUtility\" xmlns:cal= \"http://www.caliburnproject.org\" > <Grid> <hu:VisualHotkey Combination= \"Alt + Space\" cal:Message.Attach= \"[Event Pressed] = [Action VisualHotkey_Pressed($this, $eventArgs)]\" /> </Grid> </Window> Info One possible reason why it might not work is because InputBinding doesn't inherit from FrameworkElement . You Can Still Use Commands If you're more comfortable using the ICommand interface and you'd rather use a command than an event handler, that's also available as an option for both the HotkeyBinding and the VisualHotkey : ShellView.xaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 <Window xmlns= \"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x= \"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:d= \"http://schemas.microsoft.com/expression/blend/2008\" xmlns:mc= \"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns:hu= \"clr-namespace:HotkeyUtility.Controls;assembly=HotkeyUtility\" > <Window.InputBindings> <hu:HotkeyBinding Combination= \"Alt + Space\" Command= \"{Binding MyCommand}\" /> </Window.InputBindings> <Grid> <hu:VisualHotkey Combination= \"Shift + M\" Command= \"{Binding MyOtherCommand}\" /> </Grid> </Window>","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"HotkeyUtility is designed and intended to be intuitive and easy to use. This page will show a couple of quick examples to get you started using hotkeys in your WPF applications.","title":"Quickstart"},{"location":"quickstart/#creating-a-hotkey","text":"Setting up a hotkey in your application is easy. We first need to declare the HotkeyUtility XAML namespace in the root tag of your XAML file: MainWindow.xaml 1 2 3 4 5 6 7 <Window xmlns= \"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x= \"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:d= \"http://schemas.microsoft.com/expression/blend/2008\" xmlns:mc= \"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns:hu= \"clr-namespace:HotkeyUtility.Controls;assembly=HotkeyUtility\" > </Window> Once the namespace is declared, you can use the HotkeyBinding object (which inherits from InputBinding ) that's provided to you by HotkeyUtility : Simply add it to the InputBindings property of the Window : MainWindow.xaml 1 2 3 4 5 6 7 8 9 10 <Window xmlns= \"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x= \"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:d= \"http://schemas.microsoft.com/expression/blend/2008\" xmlns:mc= \"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns:hu= \"clr-namespace:HotkeyUtility.Controls;assembly=HotkeyUtility\" > <Window.InputBindings> <hu:HotkeyBinding Combination= \"Alt + Space\" Pressed= \"HotkeyBinding_Pressed\" /> </Window.InputBindings> </Window> Once that's set up, your hotkey is now registered and ready to be used. Whenever the user simultaneously presses Alt + Space , the event handler called HotkeyBinding_Pressed in the codebehind will be triggered: MainWindow.xaml.cs 1 2 3 4 5 6 7 using System ; using HotkeyUtility.Input ; public void HotkeyBinding_Pressed ( object sender , HotkeyEventArgs e ) { Console . WriteLine ( \"A hotkey was pressed\" ); }","title":"Creating a Hotkey"},{"location":"quickstart/#hotkeys-and-mvvm","text":"If you're using an MVVM framework (like Caliburn.Micro , for example), there's a chance that attaching an event handler to the Pressed event of HotkeyBinding won't work. If that's the case for you, you'll need to use the VisualHotkey control provided by HotkeyUtility . It's important to point out that the name is a bit of a misnomer; VisualHotkey has no visual properties so it won't take up any space in your application. You can use it in your XML file like in this example (which uses Caliburn.Micro ): ShellView.xaml 1 2 3 4 5 6 7 8 9 10 11 <Window xmlns= \"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x= \"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:d= \"http://schemas.microsoft.com/expression/blend/2008\" xmlns:mc= \"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns:hu= \"clr-namespace:HotkeyUtility.Controls;assembly=HotkeyUtility\" xmlns:cal= \"http://www.caliburnproject.org\" > <Grid> <hu:VisualHotkey Combination= \"Alt + Space\" cal:Message.Attach= \"[Event Pressed] = [Action VisualHotkey_Pressed($this, $eventArgs)]\" /> </Grid> </Window> Info One possible reason why it might not work is because InputBinding doesn't inherit from FrameworkElement .","title":"Hotkeys and MVVM"},{"location":"quickstart/#you-can-still-use-commands","text":"If you're more comfortable using the ICommand interface and you'd rather use a command than an event handler, that's also available as an option for both the HotkeyBinding and the VisualHotkey : ShellView.xaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 <Window xmlns= \"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x= \"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:d= \"http://schemas.microsoft.com/expression/blend/2008\" xmlns:mc= \"http://schemas.openxmlformats.org/markup-compatibility/2006\" xmlns:hu= \"clr-namespace:HotkeyUtility.Controls;assembly=HotkeyUtility\" > <Window.InputBindings> <hu:HotkeyBinding Combination= \"Alt + Space\" Command= \"{Binding MyCommand}\" /> </Window.InputBindings> <Grid> <hu:VisualHotkey Combination= \"Shift + M\" Command= \"{Binding MyOtherCommand}\" /> </Grid> </Window>","title":"You Can Still Use Commands"}]}